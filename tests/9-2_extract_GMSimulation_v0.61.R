rm(list = ls())
pkg <- c("data.table", "ggplot2", "Rose", "png")
sapply(pkg, require, character.only = TRUE)

core_path <- "[01]Projects/viscando/"
windows_path <- paste0("D:/", core_path)
unix_path <- paste0("/media/yslin/Avocet/", core_path)
wk <- ifelse(.Platform$OS.type == "windows",
             shortPathName(windows_path),
             unix_path
)
setwd(wk)
#   使用者     系統     流逝 
#  273.646   19.033 1232.220 
# 21 minutes to run

run_an_instance <- function(i, input, output) {
  # res <- parallel::mclapply(idx, run_an_instance, pyrootlist, savepathlist,
  #                           mc.cores = getOption("mc.cores", ncore)
  # i <- 1
  # input <- pyrootlist
  # output <- savepathlist
                            
  pyroot <- input[[i]]
  save2file <- output[[i]]
  
  timefiles <- list.files(pyroot, pattern = "time_stamps(1[0-2]|[0-9])*")
  a0files <- list.files(pyroot, pattern = "^(acceleration_case).*(0.txt)$")
  a1files <- list.files(pyroot, pattern = "^(acceleration_case).*(1.txt)$")

  s0files <- list.files(pyroot, pattern = "^speed(1[0-2]|[0-9]).*(0.txt)$")
  s1files <- list.files(pyroot, pattern = "^speed(1[0-2]|[0-9]).*(1.txt)$")
  
  s0_files <- list.files(pyroot, pattern = "^other_perceived_speed(1[0-2]|[0-9]).*(0.txt)$")
  s1_files <- list.files(pyroot, pattern = "^other_perceived_speed(1[0-2]|[0-9]).*(1.txt)$")
  dc0files <- list.files(pyroot, pattern = "^distance2encounter(1[0-2]|[0-9]).*(0.txt)$")
  dc1files <- list.files(pyroot, pattern = "^distance2encounter(1[0-2]|[0-9]).*(1.txt)$")
  dc0_files <- list.files(pyroot, 
                          pattern = "^other_distance2encounter(1[0-2]|[0-9]).*(0.txt)$")
  dc1_files <- list.files(pyroot, 
                          pattern = "^other_distance2encounter(1[0-2]|[0-9]).*(1.txt)$")
  
  dout <- NULL
  nfile <- length(timefiles)

  for (j in seq_len(nfile)) {
    xx <- scan(paste0(pyroot, timefiles[j]))
    a0 <- scan(paste0(pyroot, a0files[j]))
    a1 <- scan(paste0(pyroot, a1files[j]))
    s0 <- scan(paste0(pyroot, s0files[j]))
    s1 <- scan(paste0(pyroot, s1files[j]))
    
    s0_ <- scan(paste0(pyroot, s0_files[j]))
    s1_ <- scan(paste0(pyroot, s1_files[j]))
    dc0 <- scan(paste0(pyroot, dc0files[j]))
    dc1 <- scan(paste0(pyroot, dc1files[j]))
    dc0_ <- scan(paste0(pyroot, dc0_files[j]))
    dc1_ <- scan(paste0(pyroot, dc1_files[j]))
    dtmp <- data.frame(
      x = rev(xx),
      A0 = a0, A1 = a1,
      S0 = s0, S1 = s1,
      S0_ = s0_, S1_ = s1_,
      DC0 = dc0, DC1 = dc1, DC0_ = dc0_, DC1_ = dc1_,
      id = j)
    dout <- rbind(dout, dtmp)
  }
  
  d <- data.table(dout)
  save(d, file = save2file)
}

# Section 1 ------------------
# Load the data
pyrootlist <- list(
  "tests/pydata/short_stop/",
  "tests/pydata/priority_assertion/",
  "tests/pydata/hesitation/",
  "tests/pydata/early_yield/",
  "tests/pydata/short_stop_correct/",
  "tests/pydata/hestitant_crossings_correct/"
)
savepathlist <- list(
  "tests/pydata/short_stop_GM.rda",
  "tests/pydata/priority_GM.rda",
  "tests/pydata/hesitation_GM.rda",
  "tests/pydata/early_yield_GM.rda",
  "tests/pydata/short_stop_correct_GM.rda",
  "tests/pydata/hestitant_crossings_correct_GM.rda"
)

# After viewing the result generated by index 0 parameter in his
# "oVAoBEvoAI oEA oSNvoPF" model, GM instructed me to use his
# "oVAoBEvoAI oDA oSNvoPF" model, which has 193 sets of optimized
# parameters. He then instructed me to use the 193 sets to generate
# 193 simulations.
# 
# He also instructed an alternative way that uses each of the 193 sets
# to generate 100 duplicated simulations, assuming each of them is an 
# interactive observation. However, no clear theory behind this and his 
# JuypterNote book also express in a way of many possibilities 
#
# He did use the verb, "suggest" to give instructions. But my
# experience in communicating with him is that he will continue to
# press me on doing the same task, sometimes for several months, resulting a 
# halt until he gets the result of verify the accuracy of his model.
#
# Because his model is developed in a way enabling
# many optional changes in every part of equation building, in the model
# fitting procedures, and in the flexibility of inserting any equations
# that describe many philosophical ideas of how human psychology works, I do
# believe he could always find a seemingly good simulation to fit the
# resultant data. Such an approach in freeing modelling flexibility
# has been widely discussed in literature (see e.g., articles in Psychological 
# Reviews).
#
# However, in practice, other researchers will likely find his model
# encounters the cross-validation problem without his intervention.
# Because his main modelling publication has over 100 pages plus near 100
# pages replies to his reviewers, it is impossible for other researchers to
# understand the details in his unique fitting procedures. This argument 
# is supported by anyone who dare to read his Python code, which shows such a 
# puzzle.
#
# To make this task actionable, I will return to the
# "oVAoBEvoAI oEA oSNvoPF" model and use the index 0
# parameter, because this was described in his JupyterNote book as 
# "
# The maximally successful stochastic model in the paper
# was `oVAoBEvoAIoEAoSNvoPF`, i.e.,
# the same model as above, but extended also with evidence accumulation
# decision-making, angular visual noise, and Bayesian perceptual filtering.
# The same functions as above can be used with this model as well
# "
#
# This decision is based on three reasons:
# (1) the "oVAoBEvoAI oEA oSNvoPF" model, using index 0 parameter set
# results in reasonable fit to the "short-slowing" and the
# "early-yield acceptance" behaviour at the average level and
# the individual acceleration profile at the "hesitation to a yield".
#
# There are 12 observations in the short-stop case.
# There are 10 observations in the priority assertion case.
# There are 4 observations in the hesitation case.
# There are 34 observations in the hesitation case.
# So there are 60 observations in total.
#
# oVAoBEvoAI oEA oSNvoPF
ncore <- length(pyrootlist)
idx <- vector("list", length = ncore)
for (l in 1:ncore) {
  idx[[l]] <- l
}

res <- parallel::mclapply(idx, run_an_instance, pyrootlist, savepathlist,
                          mc.cores = getOption("mc.cores", ncore)
)

